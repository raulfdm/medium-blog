---
title: 'YAML para Desenvolvedores Web'
subtitle: Um guia simples para ajudar voc√™ a ler e escrever arquivos .yml'
date: '2020-03-19'
image: assets/featured-img.png
tags:
  - yml
  - introducao
  - desenvolvimento
---

Mais e mais, n√≥s, desenvolvedores web precisamos aprender sobre diferentes √°reas para nos tornarmos melhores profissionais e menos dependentes de outras pessoas para tarefas simples.

Se voc√™ j√° come√ßou sua carreira como pessoa desenvolvedora front-end, voc√™ j√° deve ter visto v√°rios arquivos `.yml`, como por exemplo, `.travis.yml` (para CI com o Travis), `.gitlab-ci.yml` (CI com o git lab), etc.. Mas vamos ser sinceros... que diabos √© isso?

Porque e para que as pessoas as pessoas usariam esse tipo de arquivo? Quais s√£o os benef√≠cios? Como isso funciona?

O objetivo desse artigo √© fazer uma introdu√ß√£o a voc√™ √† estrutura do `YAML` e te dar mais confian√ßa pra ler, entender, escrever e alterar arquivos como esse quando precisar.

Afinal, n√£o sei voc√™, mas quando eu preciso fazer uma modifica√ß√£o em algo que n√£o sei e n√£o conhe√ßo, gera um sentimento bem ruim de frustra√ß√£o.

A √∫nica forma de conseguir superar isso √© encarando de frente o problema e resolvendo, certo? Ent√£o bora!

---

## Mas antes de tudo, o que √© YAML?

De acordo com o [site oficial](https://yaml.org/), Yaml √© (tradu√ß√£o livre):

<BigQuote>
  "YAML (um acr√≥nimo recursivo para "YAML Ain't Markup Language" [algo como, n√£o
  √© uma linguagem de marca√ß√£o]) √© um padr√£o amig√°vel para serializa√ß√£o de dados
  para todas as linguagens de programa√ß√£o."
</BigQuote>

Comumente usado como arquivos de configura√ß√£o, o que explica muito, n√£o √©?

Algu√©m um dia, muito cansado de escrever um monte de arquivo de configura√ß√£o sem padr√£o nenhum pensou:

> E se a gente tivesse de alguma maneira de escrever essas configura√ß√µes como "receitas de bolo"? Tipo, texto simples e claro, direto ao ponto.

E dessa necessidade, em Maio de 2001 nasce o Yaml.

---

## YAML vs JSON

Acredite ou n√£o, Yaml √© um superset do nosso velho amigo JSON.

> "Superset √© uma linguagem de programa√ß√£o que cont√©m todas as funcionalidades de uma outra, por√©m expandida ou com mais funcionalidades." - [Fonte](https://encyclopedia2.thefreedictionary.com/superset)

Trazendo pro nosso mundo de Front-end, eu diria que :

> O Yaml est√° para o JSON assim como o TypeScript est√° para o JavaScript.

Mas para entender melhor como isso √© sequer poss√≠vel, vamos ver um exemplo:

```json:title=tsconfig.json
{
  "compilerOptions": {
    "module": "system",
    "noImplicitAny": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "outFile": "../../built/local/tsc.js",
    "sourceMap": false,
    "types": ["node", "lodash", "express"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "**/*.spec.ts"]
}
```

O arquivo acima √© um `tsconfig.json`, arquivo de configura√ß√£o que todo projeto TypeScript precisa ter.

N√≥s que temos o olho treinado no JSON, podemos achar muito simples e claro o que est√° sendo declarado, por√©m, ainda existem algumas limita√ß√µes, como por exemplo:

- N√£o criar vari√°veis;
- N√£o podemos importar ou usar vari√°veis de fora (por exemplo vari√°veis de ambiente);
- N√£o temos maneiras de sobrescrever valores, caso alguma condi√ß√£o seja atendida;

Tanto essas limita√ß√µes s√£o reais que em v√°rios projetos, quando fazemos uso de ESLint, BabelJS e queremos utilizar uma configura√ß√£o mais robustas, trocamos nosso arquivo de `JSON` para `JavaScript` (`.babelrc` -> `babel.config.js`), que ent√£o nos permite carregar configura√ß√µes condicionais e baseadas em que ambiente estamos, etc., resolvendo as limita√ß√µes mencionadas anteriormente.

Mas se voc√™ estiver usando uma outra linguagem que n√£o seja JavaScript, arquivos `.js` para configurar coisas nem s√£o uma op√ß√£o, e √© aqui que o Yaml come√ßa a brilhar.

Se pud√©ssemos reescrever o `tsconfig.json` usando a sintaxe `YAML`, seria algo como:

```yaml:title=tsconfig.yml
compilerOptions:
  module: system
  noImplicitAny: true
  removeComments: true
  preserveConstEnums: true
  outFile: '../../built/local/tsc.js'
  sourceMap: false
  types:
    - node
    - lodash
    - express
include:
  - src/**/*
exclude:
  - node_modules
  - '**/*.spec.ts'
```

> Repare que isso √© apenas um exemplo. Voc√™ n√£o pode escrever `tsconfig` em Yamlüòú

---

## Conceitos, Tipos e Sintaxe

Agora, vamos entender mais a fundo sobre os conceitos dessa linguagem.

### Indenta√ß√£o

Em Yaml, indenta√ß√£o **√© importante**. Ele usa _espa√ßos em branco_ para agrupar informa√ß√µes. Por espa√ßo em branco, entenda apenas como literalmente espa√ßo (space), uma vez que o Tab n√£o √© permitido.

> N√£o se assuste. Se voc√™, assim como eu, usa o tab para indentar c√≥digo, um simples arquivo [`.editorconfig`](<(https://editrconfig.org/)>), uma configura√ß√£o ou um plugin no editor resolvem isso facilmente. Assim, quando voc√™ apertar tab, o editor troca o caractere de Tab por barras de espa√ßos (2 ou 4).

### Ra√≠z

Uma vez que a indenta√ß√£o importa, se n√£o tiver nenhum espa√ßo antes da primeira declara√ß√£o do arquivo, o YAML vai entender que estamos escrevendo c√≥digo na ra√≠z do arquivo (no n√≠vel 0):

```yml
pessoa:
  idade: 20
```

Em formato JSON, seria equivalente a:

```json
{
  "pessoa": {
    "idade": 20
  }
}
```

### Chave/Valor

Assim como em JSON ou JavaScript, `YAML` tamb√©m usa o conceito de `key/value` (`chave/valor`). Podemos declarar de diversas maneiras:

```yml
chave: valor
chave_um: valor um
chave um: valor # Por mais estranho que pare√ßa, √© valido
'minha chave': algumvalor
```

### Coment√°rios

Diferentemente do JSON que n√£o podemos escrever coment√°rios, aqui, basta utilizarmos o caractere `#` e em seguida sua mensagem:

```yml
# Algum coment√°rio relevante
pessoa: # Outro coment√°rio
  idade: 20
```

### Listas

Existem duas maneiras de escrever listas:

#### Igual JSON: lista de strings

Lembra que Yaml √© o JSON com superpoderes? A gente pode usar a mesma sintaxe:

```yml
pessoas: ['Maria', 'Carla', 'Pedro']
```

#### Usando H√≠fen

A maneira mais comumente vista (e talvez at√© recomendada) √© quebrando uma linha e adicionando h√≠fen antes de cada valor:

```yml
pessoas:
  - Maria
  - Carla
  - Pedro
```

### Strings

Diferentemente do JSON, onde podemos usar apenas aspas duplas para declarar strings, em Yaml temos v√°rios jeitos diferentes de fazer:

<!-- prettier-ignore -->
```yml
empresa: Google # Uma palavra, sem aspas
nome_completo: Marcus da Silva # frases, sem aspas
nome: 'Cleber' # Usando aspas simples 
sobrenome: "Fernando Dias" # Usando aspas duplas
```

> Dica: d√™ prefer√™ncia para quotes quando sua string possuir qualquer caractere especial como `_`, `@`, etc.

### N√∫meros

Como em qualquer outra linguagem de programa√ß√£o, temos dois tipos de tipos num√©ricos: inteiros (integer) e decimais (float):

```yml
ano: 2019 # Inteiro
nodeVersion: 10.8 # Decimal
```

### N√≥s √¢ncoras (vari√°vel)

√Çncora √© um mecanismo muito √∫til para cria√ß√£o e grupos de dados (objetos) que podem ser injetados or estendidos por outro objeto.

Vamos imaginar que voc√™ precisa criar uma configura√ß√£o pra sua CI. Ela ter√° dois ambientes, o de produ√ß√£o (production) e o de homologa√ß√£o (staging) e como voc√™ pode imaginar, ambos possuem quase as mesmas configura√ß√µes.

No mundo JSON, ter√≠amos que duplicar as configura√ß√µes pela simples limita√ß√£o da linguagem:

```json
{
  "production": {
    "node_version": "13.0.0",
    "os": "ubuntu",
    "package_manager": "yarn",
    "run": ["yarn install", "NODE_ENV=${ENVIRONMENT} yarn build"],
    "env": {
      "ENVIRONMENT": "production"
    }
  },
  "staging": {
    "node_version": "13.0.0",
    "os": "ubuntu",
    "package_manager": "yarn",
    "run": ["yarn install", "NODE_ENV=${ENVIRONMENT} yarn build"],
    "env": {
      "ENVIRONMENT": "staging"
    }
  }
}
```

Copiar e colar √© muito chato, especialmente quando voc√™ tem alterar alguma informa√ß√£o que √© id√™ntica em ambos casos e √© aqui que √¢ncoras se destacam.

Ent√£o, aplicando o conceito, fazemos:

1. Criamos nossa √¢ncora

```yml{3}
# Eu coloquei o nome de "base-config" mas pode ser qualquer coisa que quiser
# o nome "&base" vai ser o nome da nossa vari√°vel e usaremos ele nos outros lugares
base-config: &base
  node_version: 13.0.0
  os: ubuntu
  package_manager: yarn
  run:
    - yarn install
    - NODE_ENV=${ENVIRONMENT} yarn build
```

2. Injetamos a √¢ncora criada no n√≠vel que desejamos injet√°-las. No caso, √© dentro de `production` e `staging`:

```yml{11,17}
base-config: &base
  node_version: 13.0.0
  os: ubuntu
  package_manager: yarn
  run:
    - yarn install
    - NODE_ENV=${ENVIRONMENT} yarn build

production:
  # Injetando todas os atributos e valores de "base-config"
  <<: *base
  env:
    - ENVIRONMENT: production

staging:
  # Injetando todas os atributos e valores de "base-config"
  <<: *base
  env:
    - ENVIRONMENT: staging
```

Simples, n√£o? Tamb√©m muito f√°cil de manter. Caso alguma altera√ß√£o seja feita em nossa `base-config`, ser√° automaticamente refletida em ambos ambientes.

Se voc√™ copiar e colar o c√≥digo acima em um conversor online de "Yaml para JSON", teremos quase o mesmo c√≥digo mencionado no exemplo do JSON, apenas adicionando o objeto "base-config":

```json{8-29}
{
  "base-config": {
    "node_version": "13.0.0",
    "os": "ubuntu",
    "package_manager": "yarn",
    "run": ["yarn install", "NODE_ENV=${ENVIRONMENT} yarn build"]
  },
  "production": {
    "node_version": "13.0.0",
    "os": "ubuntu",
    "package_manager": "yarn",
    "run": ["yarn install", "NODE_ENV=${ENVIRONMENT} yarn build"],
    "env": [
      {
        "ENVIRONMENT": "production"
      }
    ]
  },
  "staging": {
    "node_version": "13.0.0",
    "os": "ubuntu",
    "package_manager": "yarn",
    "run": ["yarn install", "NODE_ENV=${ENVIRONMENT} yarn build"],
    "env": [
      {
        "ENVIRONMENT": "staging"
      }
    ]
  }
}
```

### Sintaxe JSON (sim, JSON)

Como expliquei anteriormente, um superset de uma linguagem √© ela mesma mais algumas funcionalidades extras. Isso significa que podemos escrever arquivos Yaml com a sintaxe do JSON:

<!-- prettier-ignore -->
```yml
{
  "details": {
    "company": {
      "name": "Google",
      "year": 2019,
      "active": true
    },
    "employees": [
      "Anne",
      "John",
      "Max"
    ]
  }
}
```

Se usarmos novamente um conversor Yaml para JSON, veremos que tanto a entrada quanto a sa√≠da ser√£o os mesmos:

```json
{
  "details": {
    "company": {
      "name": "Google",
      "year": 2019,
      "active": true
    },
    "employees": ["Anne", "John", "Max"]
  }
}
```

> N√£o acredita? Copia e cola o c√≥digo Yaml anterior [nesta ferramenta](https://onlineyamltools.com/convert-yaml-to-json) e veja com seus pr√≥prios olhos.

### Ambientes Shell/Bash

Como disse no come√ßo do artigo, √© muito comum vermos arquivos `.yml` sendo utilizados para muitas coisas, mas especialmente para ambientes de CI/CD (Travis, Github Actions, GitLab CI, CircleCI, etc).

Nesses casos, precisamos descrever como a m√°quina ou o container deve trabalhar, o que deve ser instalado, rodado, etc.

Geralmente esses `.yml` rodar√£o em um ambiente Linux e quem est√° executando te dar√° acesso ao exterior, ou seja, a vari√°veis de ambiente, acesso a rodar shell scripts, como se fosse um terminal UNIX mesmo.

Quando usamos GitLab CI por exemplo, podemos especificar no topo do arquivo um objeto chamado `variables`. Dentro dele, tudo que for declarado ser√° injetado como vari√°vel de ambiente e poder√° ser usado dentro os processos que queremos executar:

```yml{1-2,8}
variables:
  NODE_IMAGE: node:10

stages:
  - build

test:
  image: $NODE_IMAGE
  stage: build
```

Perceba que a sintaxe de usar vari√°vel com `$` n√£o √© do Yaml, mas sim, `shell/bash`.

Dependendo da plataforma, ela tamb√©m oferece outras vari√°veis que n√£o s√£o ou est√£o declaradas dentro do arquivo, mas que podem ser acessadas tranquilamente como refer√™ncia do commit, o nome do branch, nome do autor, vari√°veis secretas (SECRETS), entre v√°rias outras:

```yml{11}
variables:
  NODE_IMAGE: node:10

stages:
  - build

test:
  image: $NODE_IMAGE
  stage: build
  artifacts:
    name: $CI_COMMIT_REF_NAME
```

No exemplo acima, usamos `$CI_COMMIT_REF_NAME` que se refere ao nome do branch para qual a integra√ß√£o esteja rodando para dar nome ao artefato que ser√° gerado ao final do processo. Ou seja, se voc√™ criou um branch chamado `nova-funcionalidade`, esse nome ser√° usado como nome do artefato.

---

## Conclus√£o

Espero que voc√™ tenha conseguido absorver os conceitos de Yaml e j√° se sinta mais confiante quando encontrar um monstrinho desses por a√≠.

Lembre-se sempre que, o que voc√™ vai ter acesso ou n√£o, vai depender de onde aquele Yaml est√° sendo utilizado. Diferentes plataformas (GitLab CI, CircleCI, Github Actions) possuem diferentes estrat√©gias de configura√ß√£o, vari√°veis e acessos.

Lembre-se sempre de checar a documenta√ß√£o da plataforma que est√° trabalhando para entender sua individualidade e o que pode ser feito ou n√£o! :)

---

## Refer√™ncias

- [YAML Website](https://yaml.org/). Site oficial. Aqui tem os conversores recomendados para todas as linguagens;
- [Learn X in Y Minutes: YAML](https://learnxinyminutes.com/docs/yaml/);
- [JSON ‚Üê‚Üí YAML Online converter](https://www.json2yaml.com/);
- [YAML by Wikipedia](https://en.wikipedia.org/wiki/YAML).
